import azure.functions as func 
import logging
import os
import json
import requests
from datetime import datetime
from azure.storage.blob import BlobServiceClient

# Get Blob Storage Connection String from Azure Function App settings
STORAGE_CONNECTION_STRING = os.getenv("AzureWebJobsStorage") # Storage Account connection string
STORAGE_CONNECTION_STRING_NEW = "" #put the storage account connection string
CONTAINER_NAME = "function-app-test"
BLOB_FILENAME = "api_data.json"  # Replace with desired blob filename
API_URL = "https://data.cdc.gov/resource/9bhg-hcku.json"

SOURCE_CONTAINER = "function-app-test"
DESTINATION_CONTAINER = "function-app-test2"

app = func.FunctionApp(http_auth_level=func.AuthLevel.ANONYMOUS)






@app.route(route="http_trigger_func")
def http_trigger_func(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')

    name = req.params.get('name')
    if not name:
        try:
            req_body = req.get_json()
        except ValueError:
            pass
        else:
            name = req_body.get('name')

    if name:
        return func.HttpResponse(f"Hello, {name}. This HTTP triggered function executed successfully.")
    else:
        return func.HttpResponse(
             "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.",
             status_code=200
        )








@app.route(route="http_trigger_api", auth_level=func.AuthLevel.ANONYMOUS)
def http_trigger_api(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Fetching data from a public API.')

    # Example: Fetching random facts from a public API (No API Key Required)
    api_url = "https://catfact.ninja/fact"

    try:
        response = requests.get(api_url)
        if response.status_code != 200:
            return func.HttpResponse(f"Error fetching data: {response.json()}", status_code=response.status_code)

        data = response.json()
        
        return func.HttpResponse(str(data), status_code=200, mimetype="application/json")

    except Exception as e:
        logging.error(f"Error: {str(e)}")
        return func.HttpResponse(f"An error occurred: {str(e)}", status_code=500)












@app.route(route="http_trigger_api_to_file", auth_level=func.AuthLevel.ANONYMOUS)
def http_trigger_api_to_file(req: func.HttpRequest) -> func.HttpResponse:
    logging.info("Fetching data from a public API.")

    # Example: Fetching random facts from a public API (No API Key Required)
    api_url = "https://catfact.ninja/fact"

    try:
        response = requests.get(api_url)
        if response.status_code != 200:
            return func.HttpResponse(f"Error fetching data: {response.json()}", status_code=response.status_code)

        data = response.json()

        # Define file path (local storage in VS Code)
        file_path = os.path.join(os.getcwd(), "fetched_data.json")

        # Save API response to a JSON file
        with open(file_path, "w", encoding="utf-8") as file:
            json.dump(data, file, indent=4)

        logging.info(f"Data successfully saved to {file_path}")

        return func.HttpResponse(f"Data successfully saved to file: {file_path}", status_code=200)

    except Exception as e:
        logging.error(f"Error: {str(e)}")
        return func.HttpResponse(f"An error occurred: {str(e)}", status_code=500)


















@app.route(route="http_trigger_api_blob", auth_level=func.AuthLevel.ANONYMOUS)

def http_trigger_api_blob(req: func.HttpRequest) -> func.HttpResponse:
    logging.info("Fetching data from a public API and saving to Blob Storage.")

    # Example: Fetching random cat facts from a public API (No API Key Required)
    #api_url = "https://catfact.ninja/fact"
    api_url = "https://data.cdc.gov/resource/9bhg-hcku.json"

    try:
        response = requests.get(api_url)
        if response.status_code != 200:
            return func.HttpResponse(f"Error fetching data: {response.json()}", status_code=response.status_code)

        data = response.json()

        # Convert JSON data to a string
        json_data = json.dumps(data, indent=4)

        # Save data to Azure Blob Storage
        blob_name = "fetched_data.json"
        save_to_blob(json_data, blob_name)

        return func.HttpResponse(f"Data successfully saved to Blob Storage: {blob_name}", status_code=200)

    except Exception as e:
        logging.error(f"Error: {str(e)}")
        return func.HttpResponse(f"An error occurred: {str(e)}", status_code=500)

def save_to_blob(data: str, blob_name: str):
    """Uploads data to Azure Blob Storage."""
    blob_service_client = BlobServiceClient.from_connection_string(STORAGE_CONNECTION_STRING_NEW)
    blob_client = blob_service_client.get_blob_client(container=CONTAINER_NAME, blob=blob_name)

    # Upload the data
    blob_client.upload_blob(data, overwrite=True)
    logging.info(f"Data saved to Blob Storage as {blob_name}")

















@app.route(route="http_trigger_move_files_from_blob", auth_level=func.AuthLevel.ANONYMOUS)
def http_trigger_copy_files_from_blob(req: func.HttpRequest) -> func.HttpResponse:
    logging.info("Starting file move operation between blob containers.")

    try:
        blob_service_client = BlobServiceClient.from_connection_string(STORAGE_CONNECTION_STRING)

        # Get the container clients
        source_container_client = blob_service_client.get_container_client(SOURCE_CONTAINER)
        destination_container_client = blob_service_client.get_container_client(DESTINATION_CONTAINER)

        # List all blobs in the source container
        blobs = source_container_client.list_blobs()
        moved_files = []

        for blob in blobs:
            source_blob_client = source_container_client.get_blob_client(blob.name)
            destination_blob_client = destination_container_client.get_blob_client(blob.name)

            # Copy blob from source to destination
            destination_blob_client.start_copy_from_url(source_blob_client.url)

            # Delete the original blob from the source container
            source_blob_client.delete_blob()
            
            moved_files.append(blob.name)

        return func.HttpResponse(f"Moved files: {moved_files}", status_code=200)

    except Exception as e:
        logging.error(f"Error moving files: {str(e)}")
        return func.HttpResponse(f"Error: {str(e)}", status_code=500)





















@app.route(route="http_trigger_actual_copy_files_inside_storageAccount", auth_level=func.AuthLevel.ANONYMOUS)
def http_trigger_actual_copy_files_inside_storageAccount(req: func.HttpRequest) -> func.HttpResponse:
    logging.info("Starting file copy operation between blob containers.")

    try:
        blob_service_client = BlobServiceClient.from_connection_string(STORAGE_CONNECTION_STRING_NEW)

        # Get the container clients
        source_container_client = blob_service_client.get_container_client(SOURCE_CONTAINER)
        destination_container_client = blob_service_client.get_container_client(DESTINATION_CONTAINER)

        # List all blobs in the source container
        blobs = source_container_client.list_blobs()
        copied_files = []

        for blob in blobs:
            source_blob_client = source_container_client.get_blob_client(blob.name)
            destination_blob_client = destination_container_client.get_blob_client(blob.name)

            # Copy blob from source to destination
            destination_blob_client.start_copy_from_url(source_blob_client.url)
            
            copied_files.append(blob.name)

        return func.HttpResponse(f"Copied files: {copied_files}", status_code=200)

    except Exception as e:
        logging.error(f"Error copying files: {str(e)}")
        return func.HttpResponse(f"Error: {str(e)}", status_code=500)




@app.route(route="http_trigger_api_to_blob_with_Timestamp_field", auth_level=func.AuthLevel.ANONYMOUS)

# Azure Function
def http_trigger_api_to_blob_with_Timestamp_field(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')

    try:
        # API URL (replace with your API endpoint)
        api_url = "https://data.cdc.gov/resource/9bhg-hcku.json"
        
        # Fetch data from API
        response = requests.get(api_url)
        response.raise_for_status()  # Raise exception for bad status codes
        api_data = response.json()

        # Add get_date field to the data
        processed_data = add_get_date(api_data)

        # Azure Blob Storage configuration
        connection_string = ""  # Replace with your connection string
        container_name = "function-app-test"  # Replace with your container name
        blob_name = "api_data_With_TodaysDate.json"  # Unique blob name

        # Initialize BlobServiceClient
        blob_service_client = BlobServiceClient.from_connection_string(connection_string)
        container_client = blob_service_client.get_container_client(container_name)

        # Upload JSON data to Blob Storage
        blob_client = container_client.get_blob_client(blob_name)
        blob_client.upload_blob(json.dumps(processed_data), overwrite=True)

        return func.HttpResponse(
            f"Data successfully uploaded to Blob Storage: {blob_name}",
            status_code=200
        )

    except Exception as e:
        logging.error(f"Error occurred: {str(e)}")
        return func.HttpResponse(
            f"Error: {str(e)}",
            status_code=500
        )

# Helper function to add get_date field
def add_get_date(data):
    """
    Adds a 'get_date' field with current UTC timestamp to the API data.
    
    Args:
        data: The API response data (list or dict)
    
    Returns:
        Modified data with 'get_date' field
    """
    current_time = datetime.now().isoformat()
    
    if isinstance(data, list):
        # If data is a list, add get_date to each item
        return [{**item, "get_date": current_time} for item in data]
    elif isinstance(data, dict):
        # If data is a dict, add get_date to it
        return {**data, "get_date": current_time}
    else:
        # If data is neither, return as is with get_date in a new dict
        return {"data": data, "get_date": current_time}test
